# .github/workflows/task.yml

# Workflow 的名稱
name: 每天讓 GEMINI 生成一段名言佳句

# 觸發 Workflow 的條件
on:
  workflow_dispatch: # 允許手動觸發
  schedule:
    # 使用 cron 語法來設定定時執行 (UTC 時間)
    # '30 01 * * *' 表示 01:30 (UTC)
    # 換算成台灣時間 (UTC+8) 是早上 09:30
    - cron: '30 01 * * *'

# 工作內容
jobs:
  run-gemini-cli:
    runs-on: ubuntu-latest
    permissions:
      contents: write # 允許讀寫
    steps:
      # 步驟 1: 將專案檔案 (例如 content.json) checkout 到執行環境
      - name: Checkout repository
        uses: actions/checkout@v4

      # 步驟 2-1: 設定 Node.js v20 環境
      - name: Set up Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # 步驟 2-2: 全域安裝最新版的 @google/gemini-cli
      - name: Install Gemini CLI globally
        run: npm install -g @google/gemini-cli@latest

      # 步驟 3: 執行 GeminiCLI
      - name: Run Gemini to Get Quote and Update JSON
        env:
          # ❗️❗️❗️ 重要：請確保您在 GitHub Secrets 中建立的 Secret 名稱是 GEMINICLI_KEY
          GEMINI_API_KEY: ${{ secrets.GEMINICLI_KEY }}
        run: |
          # A. 建立 .gemini/settings.json 檔案來設定 temperature
          echo "A. 正在建立 .gemini/settings.json 檔案..."
          mkdir -p .gemini
          echo '{ "generation_config": { "temperature": 0.9 } }' > .gemini/settings.json
          echo "A. 檔案建立完成。"

          # B. 取得台北時區的當前日期
          CURRENT_DATE=$(TZ="Asia/Taipei" date +'%Y-%m-%d')
          echo "B. 取得日期: $CURRENT_DATE"

          # ⬇️⬇️⬇️ 這裡是新增的核心邏輯 ⬇️⬇️⬇️
          FILE_NAME="content.json"
          HISTORY_CONTEXT="" # 先初始化一個空的「歷史上下文」變數

          # C. 檢查 JSON 檔案並讀取歷史紀錄 (最新的 10 筆)
          if [ -f "$FILE_NAME" ]; then
            echo "C. 發現 $FILE_NAME，正在讀取最近 10 筆紀錄..."
            
            # 使用 jq 讀取：
            # .[0:10]  -> 取得陣列中前 10 個 (因為我們是從前面插入，所以前 10 個就是最新的)
            # .[] | .poem -> 展開陣列並只取出 "poem" 欄位的值
            # -r         -> 輸出原始字串 (不要加上引號)
            # sed 's/^/- /' -> 在每一行的開頭加上 "- "，變成一個列表
            HISTORY_LIST=$(jq -r '.[0:10] | .[] | .poem' "$FILE_NAME" | sed 's/^/- /')
            
            # 如果 $HISTORY_LIST 不是空的，才組合上下文
            if [ -n "$HISTORY_LIST" ]; then
              HISTORY_CONTEXT="為了避免重複，這裡是我已經有的名言佳句，請不要給我這個列表中的任何一句：\n${HISTORY_LIST}\n\n"
              echo "C. 已成功組合歷史紀錄上下文。"
            fi
          else
            echo "C. $FILE_NAME 不存在，將建立新檔案。"
            echo "[]" > "$FILE_NAME" # 如果檔案不存在，建立一個空的
          fi
          
          # D. 組合最終的 Prompt
          BASE_PROMPT="請隨機給我一句不同以往的、勵志的名言佳句，並包含作者。請只回傳「名言 - 作者」這個格式，不要有任何其他多餘的文字。請使用繁體中文。"
          
          # 將「歷史上下文」和「基本提示詞」組合在一起
          FINAL_PROMPT="${HISTORY_CONTEXT}${BASE_PROMPT}"
          
          # (除錯用) 印出最終的提示詞 (但金鑰會被 GitHub Actions 自動遮蔽)
          # echo "--- 最終的 Prompt ---"
          # echo "$FINAL_PROMPT"
          # echo "---------------------"
          
          # E. 詢問 geminicli
          echo "E. 正在向 Gemini 請求 (高創意/無重複) 名言佳句..."
          # 使用 $FINAL_PROMPT 變數
          POEM=$(gemini "$FINAL_PROMPT")
          # ⬆️⬆️⬆️ 邏輯更新完畢 ⬆️⬆️⬆️

          # F. 簡易的錯誤處理
          if [ -z "$POEM" ]; then
            echo "錯誤：Gemini 未回傳內容。可能是 API Key 問題或請求失敗。"
            exit 1
          fi
          echo "E. 取得的內容: $POEM"

          # G. 每次執行會把 取得的 資料 寫入到 content.json 中
          echo "G. G. 正在將新資料寫入 $FILE_NAME..."
          NEW_ENTRY=$(jq -n \
                        --arg date "$CURRENT_DATE" \
                        --arg poem "$POEM" \
                        '{date: $date, poem: $poem}')
          
          jq --argjson new_entry "$NEW_ENTRY" '. = [$new_entry] + .' "$FILE_NAME" > tmp.json && mv tmp.json "$FILE_NAME"

          echo "G. 寫入完成。"
          echo "--- 檔案目前內容 (前 5 筆) ---"
          jq '. | .[0:5]' "$FILE_NAME"
          echo "-----------------------------"

      # 步驟 4: Commit 並 Push 更新後的 JSON 檔案
      - name: Commit and Push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
          # 只 add content.json 這個檔案
          git add content.json

          # 檢查是否有檔案變更，如果有才執行 commit 和 push
          # ! git diff --staged --quiet; 意思是 "如果 staged 區不是空的"
          if ! git diff --staged --quiet; then
            # 在 commit message 中加入日期，方便追蹤
            git commit -m "feat(bot): ✨ 新增 $(TZ="Asia/Taipei" date +'%Y-%m-%d') 的詩句"
            git push
          else
            echo "沒有變更，無需 commit。"
          fi
